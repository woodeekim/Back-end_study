## 람다 표현식

들어가기 전
- 익명 클래스로 다양한 동작을 구현할 수 있지만 만족할 만큼 코드가 깔끔하지는 않았다.
    - 깔끔하지 않은 코드는 동작 파라미터를 실전에 적용하는 것을 막는 요소다.
- 더 깔끔한 코드로 동작을 구현하고 전달하는 자바 8의 새로운 기능인 람다 표현식 설명한다.
- 람다 표현식은 익명 클래스처럼 이름이 없는 함수면서 메서드를 인수로 전달할 수 있으므로 일단은 람다 표현식이 익명 클래스와 비슷하다고 생각하자.
- 마지막으로 람다 표현식과 함께 위력을 발휘하는 새로운 기능인 메서드 참조를 설명한다.

### 3.1 람다란 무엇인가?
람다 표현식
- 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다.
- 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.
- 익명
    - 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다.
- 함수
    - 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트 바디, 반환 형식, 가능한 예외 리스트를 포함한다.
- 전달
    - 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성
    - 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.
- 람다
    - 람다라는 용어는 람다 미적분학 학계에서 개발한 시스템에서 유래했다.
- 람다를 사용하면 동작 파라미터를 이용할 때 익명 클래스 등 판에 박힌 코드를 구현할 필요가 없다.
    - 코드가 간결하고 유연해진다.
- 다음은 기존 코드와 람다를 이용한 코드다
```java
// 이전 코드
Comparator<Appple> byWeight = new Comparator() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
};

// 람다 코드
Comparator<Apple> byWeight = (Apple a1, Apple a2 -> a1.getWeight().compareTo(a2.getWeight());
```
- 중요한 것은 사과 두 개의 무게를 비교하는 데 필요한 코드를 전달할 수 있다는 점이다.
- 람다 표현식을 이용하면 compare 메서드의 바디를 직접 전달하는 것처럼 코드를 전달할 수 있다.
- 자바 설계자는 이미 C# 이나 스칼라 같은 비슷한 기능을 가진 다른 언어와 비슷한 문법을 자바에 적용하기로 했다.
- 다음은 표현식 스타일 람다라고 알려진 람다의 기본 문법이다.
```java
(parameters) -> expression
// 또는
(parameters) -> { statements; }
```
- 다음은 람다 예제와 사용 사례를 보여준다.
```java
// 불리언 표현식
(List<String> list) -> list.isEmpty()

// 객체 생성
() -> new Apple(10)

//객체에서 소비
(Apple a) -> {
    System.out.println(a.getWeight());
}

// 객체에서 선택/추출
(String s) -> s.length()

// 두 값을 조합
(int a, int b) -> a * b

// 두 객체 비교
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

### 3.2 어디에, 어떻게 람다를 사용할까?
- 2장에서 구현했던 필터 메서드에도 람다를 활용할 수 있었다.
```java
List<Apple> greenApples = filter(inventory, (Apple a) -> GREEN.equlas(a.getColor()));
```
- 그래서 정확히 어디에서 람다를 사용할 수 있다는 건가?
    - 정답은 함수형 인터페이스라는 문백에서 람다 표현식을 사용할 수 있다.
    - 위 예제에서는 함수형 인터페이스 Predicate<T>를 기대하는 filter 메서드의 두 번째 인수로 람다 표현식을 전달했다.

#### 3.2.1 함수형 인터페이스
- 함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다.
- 지금까지 살펴본 자바 API의 함수형 인터페이스로 Comparator, Runnable 등이 있다.

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}
public interface Runnable {
    void run();
}
```
- 함수형 인터페이스는 어떤 역할을 할까?
    - 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 `전체 표현식을 함수형 인터페이스의 인스턴스로 취급`(기술적으로 따지면 함수형 인터페이스를 구현한 클래스의 인스턴스)할 수 있다.

#### 3.2.2 함수 디스크립터
함수 디스크립터
- 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
- 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.
- Runnable 인터페이스의 유일한 추상 메서드 run은 인수와 반환값이 없으므로 Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.
- 람다 표현식은 변수에 할당하거나 함수형 인터페이스를 인수로 받는 메서드로 전달할 수 있으며, 함수형 인터페이스의 추상메서드와 같은 시그니처를 갖는다.

@FunctionalInterface
- 함수형 인터페이스임을 가리키는 어느테이션이다.
- @FunctionalInterface로 인터페이스를 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다.

```java
// 다음 코드애서는 중괄호를 사용하지 않았고 void를 반환하므로 완벽한 표션익이 아닌 것처럼 보이지만 한 개의 void 메서드 호출은 중괄호로 감쌀 필요가 없다.
process(()-> System.out.println("This is awesome!!!"));
```

람다 표현식
- 언어 설계자들은 자바에 함수 형식을 추가하는 방법도 대단으로 고려했지만 더 복잡하게 만들지 않는 현재 방법을 선택했다.
- 대부분의 자바 프로그래머가 하나의 추상 메서드를 갖는 인터페이스에 이미 익숙하다는 점도 고려했다.
￿
