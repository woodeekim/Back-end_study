## 자바 8,9,10,11

### 역사의 흐름
자바8
- 간결한 코드, 멀티코어 프로세서의 쉬운 활용리나느 두 가지 요구사항을 기반으로 한다.
- 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 스트림이라는 새로운 API를 제공한다.
    - 스트림 API 덕분에 메서드에 코드를 전달하는 간결 기법인 메서드 참조와 람다 및 인터페이스의 디폴트 메서드가 존재 할 수 있음을 알 수 있다.
- 자바 8 기법은 함수형 프로그래밍에서 위력을 발휘한다.
```java
- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드
```
스트림 처리
- 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
- 이론적으로 프로그램은 입력 스트림에서 데이터를 한개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.
- 스트림 API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 생각하자.
- 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다.
    - 쓰레드라는 복잡한 작업을 사용하지 않으면서 공짜로 병렬성을 얻을 수 있다.

동작 파라미터화로 메서드에 코드 전달하기
- 자바 8에 추가된 두 번째 개념은 코드 일부를 API로 전달하는 기능이다.
    - 자바 8 이전의 자바에서는 메서드를 다른 메서드로 전달할 방법이 없다.
    - 즉 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다는 말이다.
    - 동작 파라미터화라고 부른다.
- 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항이다.
    - 명령형 프로그래밍 패러다임에서는 일련의 가변 상태로 프로그램을 정의한다.

메서드와 람다를 일급 시민으로
- 자바에서 메서드와 클래드 등은 이급 시민에 해당한다.
    - 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 바꾸기 위해 자바 8 설계자들은 바꾸는 기능을 추가했다.
- 메서드 참조 예제
    - 자바 8 이전에는 각 행이 무슨 작업을 하는지 투명하지 않다
    - 자바 8의 메서드 참조인 ::(이 메서드를 값으로 사용하라는 의미)를 이용해서 listFiles에 직접 전달할 수 있다.
        - isHidden이라는 함수는 이전에도 있던 함수이다.
        - 여기서 isHidden를 메서드가 아닌 함수라는 용어를 사용했다는 사실도 주목하자.
```java
// 자바 8 이전
File[] huddebFiles = new File(".").listFiles(new FileFilter(){
    public boolean accept(File file){
        return file.isHidden();
    }
});

// 자바 8
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
- 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다(또는 익명함수)를 포함하여 함수도 값으로 취급할 수 있다.
- 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.
- 람다 문법 형식으로 구현된 프로그래밍을 함수형 프로그래밍, 즉 함수를 일급값으로 넘겨주는 프로그램을 구현한다 라고 한다.

예제
- 특정 항목을 선택해서 반환하는 동작을 필터(filter)라고 한다.
```java
// 자바 8 이전
// 조건1) 모든 녹색 사과를 선택해서 반환
public static List<Apple> filterGreenApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>();

    for(Apple apple : inventory){
        if (Green.equlas(apple.getColor())){
            result.add(apple)
        }
    }
    return result;
}
// 조건2) 사과를 무게(150그램 이상)로 필터링
public static List<Apple> filterHeavyApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>();

    for(Apple apple : inventory){
        if (apple.getWeight() > 150){
            result.add(apple)
        }
    }
    return result;
}

//자바 8
public static boolen isGreenApple(Apple apple){
    return GREEN.equlas(apple.getColor());
}

public static boolean isHeavyApple(Apple apple){
    return apple.getWeight() > 150;
}

public interface Predicate<T>{
    boolen test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p){
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory){
        if (p.test(apple)){ // 사과는 p가 제시하는 조건에 맞는가?
            result.add(apple);
        }
    }
}

// 다음처럼 메서드를 호출
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```
- 자바 8 이전 코드의 문제
    - 복사 및 붙여넣기의 코드는 버그가 있다면 모든 코드를 고쳐야 한다.
    - 두개의 메서드는 조건절인 한 줄의 코드만 다르다.
- 자바 8에서는 코드를 인수로 넘겨줄 수 있으므로 filter메서드를 중복으로 구현할 필요가 없다.
- 여기서 핵심, 자바 8 에서는 메서드를 전달할 수 있다는 사실이다.
- 프레디케이트(predicate)란?
    - 수학에서는 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트라고 한다.
