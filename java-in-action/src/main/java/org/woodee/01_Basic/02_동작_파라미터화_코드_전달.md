## 동작 파라미터화(behavior parameterization) 코드 전달하기
### 2.1 변화하는 요구사항에 대응하기
- 동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.
- 동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다.
- 변화에 대응하는 코드를 구현하는 방법은 하나의 예제를 선정한 다음 예제 코드를 점차 개선하면서 유연하 코드를 만들면 된다.
    - 기존의 농장 재고목록 애플리케이션에 리스트에서 녹색 사과만 필러팅하는 기능을 추가한다고 가정
첫 번째 시도 : 녹색 사과 필터링
```java
enum Color { RED, GREEN }

public static List<Apple> filterGreenApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>(); // 사과 누적 리스트
    for (Apple apple : inventory) {
        if ( GREEN.equals(apple.getColor()) ){ // 녹색 사과만 선택
            result.add(apple);
        }
    }
    return result;
}
```
- 그런데 갑자기 농부가 변심하여 녹색 사과 말고 빨간 사과도 필터링하고 싶어졌다.
    - 크게 고민하지 않으면 메서드를 복사해서 filterRedApples라는 새로운 메서드와 if문이의 조건을 바꾸는 방법을 선택할 수 있다.
    - 이와 같은 방법을 사용하면 나중에 농부가 좀 더 다양한 색으로 필터링하는 등의 변화에는 적절하게 대응할 수 없다.
    - 이런 상황에서는 다음과 같은 좋은 규칙이 있다.
    - 거의 비슷한 코드가 반복 존재한다면 그 코드를 추상화한다.
    
두 번째 시도 : 색을 파라미터화
- 색을 파라미터화할 수 있도록 메서드에 파라미터를 추가하면 변화하는 요구사항에 좀 더 유연하게 대웅하는 코드를 만들 수 있다.
```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ( apple.getColor().equlas(color)){
            result.add(apple);
        }
    }
    return result;
}
```
```java
//구현한 메서드 호출
List<Apple> greenApples = filterApplesByColor(inventory, GREEN);
List<Apple> redApples = filterApplesByColor(inventory, RED);
```
- 정말 잘 해결된 듯 보였지만 농부가 나타나 다음과 같은 요구사항을 전달했다.
    - 색이외에도 가벼운 사과와 무거운 사과로 구분
    - 보통 무게가 150그램 이상인 사과가 무거운 사과이다.
- 농부의 다양한 요구사항을 듣다보면 색과 마찬가지로 앞으로 무게의 기준도 얼마든지 바뀔 수 있다는 사실에 무게 정보 파라미터도 추가했다.
```java
public static List<Apple> filterAppleByWeight(List<Apple> inventory, int weight){
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ( apple.getWeight() > weight) {
            result.add(apple);
        }
    }
    return result;
}
```
- 위 코드도 좋은 해결책이지만 목록을 검색하고, 각 사과에 필터링 조건을 적용하는 부분의 코드가 색 필터링 코드와 대부분 중복된다.
    - 이는 소프트웨어 공학의 DRY(don`t repeat yourself) 원칙을 어기는 것이다.
- 색과 무게를 filter라는 메서드로 합치는 방법도 있다.
    - 그러면 어떤 기준으로 사과를 필터링할지 구분하는 또 다른 방법이 필요하다.
    - 색이나 무게 중 어떤 것을 기준으로 필터링할지 가리키는 플래그를 추가할 수 있지만 실전에서는 절대 이 방법을 사용하지 말아야 한다(이유는 뒤에)
세 번째 시도 : 가능한 모든 속성으로 필터링
```java
public static List<Apple> filterApples(List<Apple> inventory, Color color, int weight, boolean flag) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if ((flag && apple.getColor().equlas(color)) || (flag && apple.getWeight() > weight)) { // 색이나 무게를 선택하는 방법이 마음에 들지 않는다.
            result.add(apple);
        }
    }
} 
```
- 다음처럼 위 메서드를 사용할 수 있지만 정말 마음에 들지 않는 코드다.
```java
List<Apple> greenApples = filterApples(inventory, GREEN, 0, true);
List<Apple> heavyApples = filterApples(inventory, null, 150, false);
```
- 형편없는 코드다. 이유는 다음과 같다.
    - true와 false는 무엇을 의미하는지 모른다. 
    - 앞으로 요구사항이 바뀌었을 때 유연하게 대응할 수도 없다.
- filterApples에 어떤 기준으로 사과를 필터링할 것인지 효과적으로 전달하는 방법은 동작 파라미터화를 이용해서 유연성을 얻는 방법이 있다.

### 2.2 동작 파라미터화
- 우리의 서택 조건을 다음처럼 결정할 수 있다.
    - 사과의 어떤 속성에 기초해서 불리언값을 반환
    - 참 또는 거짓을 반환하는 함수를 프레디케이트라고 한다.
    - 선택 조건을 결정하는 인터페이스를 정의해보자.
- 다음 예제 처럼 다양한 선택 조건을 대표하는 여러 버정늬 ApplePredicate를 정의할 수 있다.
```java
public interface ApplePredicate {
    public boolean test (Apple apple);
}
```
- 다음 예제처럼 다양한 선택 조건을 대표하는 여러 버전의 ApplePredicate를 정의할 수 있다.
```java
public class AppleHeavyWeightPredicate implements ApplePredicate { // 무거운 사과만 선택
    public boolean test(Apple apple){
        return apple.getWeight() > 150;
    }
}
public class AppleGreenColorPredicate implements ApplePredicate { // 녹색 사과만 선택
    public boolean test(Apple apple) {
        return GREEN.equlas(apple.getColor());
    }
}
```
- 위 조건에 따라 filter 메서드가 다르게 동작할 것이라고 예상할 수 있다.
- 이를 전략 디자인 패턴(strategy design pattern)이라고 부른다.
    - 전략 디자인 패턴은 각 알고리즘을 캡슐화하는 알고리즘 패밀리를 정의해둔 다움에 런타임에 알고리즘을 선택하는 기법이다.
- 우리 예제에서는 ApplePredicate가 알고리즘 패밀리고 AppleHeavyWeightPrediate와 AppleGreenColorPredicate가 전략이다.
<img width="992" alt="2-1_전략_디자인패턴" src="https://user-images.githubusercontent.com/44364909/88483027-1b6bfb80-cfa0-11ea-9088-67f4849a2416.png">
- 그런데 ApplePredicate는 어ㅓㄸㅎ게 다양한 동작을 숳애할 수 있을까
    - filterApples에서 ApplePredicate 객체를 받아 애플의 조건을 검사하도록 메서드를 고쳐야 한다.
    - 이ㅓㄹㅎ게 동작 파라미터화, 즉 메서드가 다양한 동작(또는 전략)을 받아서 내부저긍로 다양한 동작을 수행할 수 있다.
- filterApples 메서드가 ApplePredicate 객체를 인수로 받으면 내부에서 컬렉션을 반복하는 로직과 컬렉션의 각 요소에 적용할 동작을 분리할 수 있다는 점에서 큰 이득을 얻는다.

네 번째 시도 : 추상적 조건으로 필터링
```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory){
        if (p.test(apple)) { // 프레디케이트 개겣로 사과 검사 조건을 캡슐화했다.
            result.add(apple);
        }
    }
}
``` 
코드/동작 전달하기 
- 첫 번째 코드에 비해 더 유연한 코드를 얻었으며 동시에 가독성도 좋아졌을 뿐 아니라 사용하기도 쉬워졌다.
- 예를 들어 농부가 150 그램이 넘는 빨간 사과를 검색해달라고 부탁한다면 ApplePredicate를 적절하게 구현하는 클래스만 만들면 된다.
```java
public class AppleRedAndHeavyPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return RED.equlas(apple.getColor()) && apple.getWeight() > 150;
    }
}

// 호출
List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate());
```
- 우리가 전달한 ApplePredicate 객체에 의해 filterApples 메서드의 동작이 결정된다.
    - 우리는 filterApples 메서드의 동작을 파라미터화한 것이다.
<img width="777" alt="2-2_동작을_파라미터화" src="https://user-images.githubusercontent.com/44364909/88483610-ed88b600-cfa3-11ea-8148-8372021fd7ce.png">
- 메서드는 객체만 인수로 받으므로 test 메서드를 ApplePredicate 객체로 감싸서 전달한다.
    - 람다를 이용하면 여러 개의 ApplePredicate 클래스를 정의하지 앟고도 표현식을 메서드로 전달할 수가 있다.

한 개의 파라미터, 다양한 동작
- 컬렉션 탐색 로직과 각 항목에 적용할 동작을 분리할 수 있다는 것이 동작 파라미터화의 강점이다.



