### JPA-basic Note

JPA에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트 (엔티티를 영구 저장하는 환경)

영속성 컨텍스트의 이점
- 1차 캐시는 한 번 조회한걸 또 조회하면 디비에 쿼리가 안날라간다. (동일한 트랜젝션)
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연, 즉 버퍼링
- 변경 감지, 업데이트를 할 때
- 지연 로딩 (실무에서 중요한 개념이다. 뒤에서 많이 나올 예정)

플러시
- 영속성 컨텍스트에 현재 변경사항과 데이터베이스를 맞추는 작업이다.
- 즉 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는 것이다.
- 데이터베이스 트랜젝션이 커밋되면 플러시가 자동으로 발생한다고 보면 된다.
- 트랜젝션 커밋과 JPQL 쿼리를 실행하면 플러시가 자동 호출된다. 
- 플러시는 영속성 컨텍스트를 비우는게 아니다.

필드와 컬럼 맵핑

연관관계 매핑 기초
양방향 연관관계
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정
- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
    - JPA를 사용하고 설계를 시작한다면 우선 단방향 매핑으로 설계를 끝내야된다. 
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐이다.
- JPQL에서 역방향으로 탐색할 일이 많다.
- 단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 된다. (테이블에 영향을 미치지 않음)

##### 다양한 연관관계 매핑
- 고려사항 1.다중성 2.단방향, 양방향 3.연관관계의 주인
- 다대다는 현업에서 사용하면 안된다. (김영한님 얘기)
- 테이블은 외래키 하나로 양쪽 조인이 가능 (방향이라는 개념이 없음) /
    - 멤버와 팀이 있을 때 외래키를 양쪽에 셋팅을 하지 않고 한쪽만 갖고 있으면 양쪽에서 조인 가능
- 객체는 참조용 필드가 있어야 있는 쪽으로 참조가 가능
    - 한쪽만 참조하면 단방향
    - 양쪽이 서로 참조하면 양방향 (사실은 단방향이 두개)
-> 테이블 기준에서 외래키를 갖고 있으면 서로 조인이 되는 것처럼 객체 또한 외래키 같이 설정을 해야되는데 그게 바로 연관관계의 주인이다.
-> 양쪽을 서로 참조하도록 개발
일대다(1:N)
- DB 입장에서는 무조건 N(다)쪽에 외래키가 들어가야한다.
- 일대다 단방향은 일대다에서 일이 연관관계의 주인이다 
- 테이블 일대다 관계는 항상 다쪽에 외래 키가 있다.
- 객체와 테이블의 차이 때문에 반대 편의 테이블의 외래키를 관리하는 특이한 구조다.
- @JoinCoulumn 을 사용하지 않으면 조인 테이블을 사용한다. (안넣을시 중간에 테이블이 하나 추가되 )
- 일대다 단방향 매핑의 단점
    - 엔티티가 관리하는 외래 키가 다른 테이블에 있다.(어마어마한 단점)
    - 연관관계 관리를 위해 추가로 UPDATE SQL 을 실행한다. 
    - 일대다 단방향 매핑보다는 * 다대일 양방향 매핑을 사용하자. (공식적인 스펙에는 일대다 양방향 매핍이 없다.)

```java
// 매핑도 되어있고 다 사용하지만 다음 옵션을 주면 읽기 전용으로 된다. 
@ManyToOne
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
```

일대일(1:1)
- 주 테이블에 외래 키 단방향

다대다(N:M)
- 현업에서는 사용하지 않는다 
- 사용하려면 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
    - 일대다, 다대입 입 
- PK는 의미없는 값이어야 좋다. 만약 Id가 어디에 종속되는 식으로 걸리면 시스템을 유연스럽게 바꾸늑네 쉽지가 않다.



기타
- 1차 캐시에 올라간 상태가 영속 상태이다. (즉 JPA 가 관리하는 상태를 말함)
- 영속성 컨텍스트는 눈에 보이는 개념은 아니다. 
- 엔티티매니저를 통해서 영속성 컨텍스트에 접근한다.
- 1차 캐시가 영속성 컨텍스트라고 이해하면 된다. (스프링과 함께 쓸 때는 약간의 개념이 바뀌니 참고)
- 테이블 중심이 아니라 객체 중심
- @Entity 가 붙은 클래스는 JPA 가 관리하는 객체고 이거를 데이터베이스 테이블과 맵핑한다.
- 데이터베이스 스키마 자동 생성
    
