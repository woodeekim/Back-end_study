### 제네릭스(generics)
- 제네릭스는 JDK 1.5부터 도입
- 제네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능이다.
- 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.
    - 타입 안정성을 높인다는 것은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄여준다.
- 다룰 객체의 타입을 미리 명시해줌으로써 번거로운 형변환을 줄여준다.
제네릭스의 장점
- 타입 안정성을 제공
- 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.

제네릭 클래스의 선언
- 제네릭 타입은 클래스와 메서드에 선언할 수 있다.
```java
// 제네릭 변경 전
class Box {
    Obejct item;

    void setItem(Object item) {
        this.item = item;
    }   
    
    Object getItem(){
        return item;
    }
}
// 제네릭 변경 후
class Box<T> { 
    T item;
    
    void setItem(T item) {
        this.item = item;
    }
    
    T getItem() {
        return item;    
    }
}
```
- Box<T>에서 T를 타입 변수라고 하며, Type의 첫 글자에서 따온 것이다.
    - 타입변수는 T가 아닌 다른 것을 사용해도 된다.
- ArrayList<E>의 경우, 타입 변수 E는 Element(요소)의 첫 글자를 따서 사용했다.
- 타입 변수가 여러 개인 경우에는 Map<K,V>와 같이 콤마를 구분해서 나열하면 된다.
- 기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴타입으로 Object타입 대신 원하는 타입을 지정하기만 하면 된다.
```java
// 제네릭 클래스가 된 Box 클래스의 객체를 생성할 때
Box<String> b = new Box<String>(); // 타입 T 대신, 실제 타입을 지정
b.setItem(new Object()); // 에러. String 이외의 타입은 지정불가
b.setItem("ABC");
String item = b.getItem(); 
```

제네릭스의 용어
- 타입 문자 T는 제네릭 클래스 Box<T>의 타입 변수 또는 타입 매개변수라고 한다.
- Box<String>과 Box<Integer>는 제네릭 클래스에 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 이 둘의 별개의 클래스를 의미하는 것은 아니다.
    - add(3,5)와 add(2,4)가 서로 다른 메서드를 호출하는 것이 아닌 것과 같다.
    - 컴파일 후에 Box<String>과 Box<Integer>는 이들의 원시 타입인 Box로 바뀌게 된다. 즉 제네릭 타입이 제거된다.

제네릭스의 제한
- 제네릭 클래스 Box의 객체를 생성할 때 객체별로 다른 타입을 지정하는 것은 적절하다.
- 제네릭스는 인스턴스별로 다르게 동작하도록 하려고 만든 기능이기 때문이다.
```java
Box<Apple> appleBox = new Box<Apple>(); // Apple객체만 저장 가능
Box<Grape> grapeBox = new Box<Grape>(); // Grape객체만 저장 가능
```
- 그러나 모든 개게에 대해 동일하게 동작해야하는 static멤버에는 타입 변수 T를 사용할 수 없다. (T는 인스턴스변수로 간주)
- 제네릭 타입의 배열을 생성하는 것도 허용되지 않는다.
    - 제네릭 배열을 생성할 수 없는 것은 new연산자 때문인데 이 연산자는 펌파일 시점에 타입 T가 뭔지 정확히 알아야한다.

제네릭 클래스의 객체 생성과 사용
- jdk 1.7부터는 추정이 가능한 경우 타입을 생략할 수 있다.
```java
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<>();
```

제한된 제네릭 클래스
- 제네릭 타입에 extends를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
```java
class FruitBox<T extends Fruit> {   // Fruit의 자손만 타입으로 지정 가능
    ArrayList<T> list = new ArrayList<T>();
}
```
- 다형성에서 조상타입의 참조변수로 자손타입의 객체를 가리킬 수 있는 것처럼, 매개변수화된 자손 타입도 가능한 것이다.

와일드 카드
- 제네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문에 컴파일 에러가 발생한다.
- 제네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거해버린다.
- 와일드 카드는 기호 "?"로 펴햔하는데 어떠한 타입도 될 수 있다.
    - "?" 만으로는 Object타입과 다를 게 없으므로, extends와 super로 상한과 하한을 제한할 수 있다.
```java
// 제네릭 클래스와 달리 와일드 카드에는 &를 사용할 수 없다.
<? extends T> 와일드 카드의 상항 제한. T와 그 자손들만 가능
<? super T> 와일드 카드의 하한 제한. T와 그 조상들만 가능
<?> 제한 없음. 모든 타입의 가능. <? extends Object>와 동일
```
지네릭 메서드
- 메서드의 선언부에 제네릭 타입이 선언되 메서드를 제네릭 메서드라고 한다.
- Collections.sort()가 바로 제네릭 메서드이며 제네릭 타입의 선언 위치는 반환 타입 바로 앞이다.
```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```
- 제네릭 클래스에 정의된 타입 매개변수와 제네릭 메서드에 정의된 타입 매개변수는전혀 별개의 것이다.
- 같은 타입 문자 T를 사용해도 같은 것이 아니라는 것에 주의
- static 멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 제네릭 타입을 선언하고 사용하는 것은 가능하다.
    - 메서드에 선언된 제네릭 타입은 지역 변수를 선언한 것과 같다. 이 타입 매개변수는 메서드 내에서만 지역적으로 사용된다.
 ```java
// 제네릭 메서드는 매개변수의 타입이 복잡할 때 유용하게 쓰인다

// 제네릭 메서드 사용전
public static void printAll(ArrayList<? extends Product> list, ArrayList<? extends Product> list2){ // 와일드 카드의 상한 제한, Product와 그 자손들만 가능
    for(Unit u: list) {
        System.out.println(u);
    }
}
// 제네릭 메서드 사용후
public static <T extends Product> printAll(ArrayList<T> list, ArrayList<T> list2){
    for(Unit u: list){
        System.out.println(u);
    }   
}
```
```java
// 알아두면 좋다
    Optional<?> EMPTY = new Optional<>();
->  Optional<? extends Object> EMPTY = new Optional<>();
->  Optional<? extends Object> EMPTY = new Optional<Object>();
```
- <?>는 <? extends Object>를 줄여 쓴 것이다.
- <>안에 생략된 타입은 "?"가 아니라 Object이다.
- Optional<Object>를 Optional<String>으로 직접 형변환하는 것은 불가능하지만, 와일드 카드가 포함된 제네릭 타입으로 형변환하면 가능하다.

제네릭 타입의 제거
- 컴파일러는 제네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에 형변환을 넣어준다. 그 후 제네릭 타입을 제거한다.
    - 즉 컴파일된 파일(*.class)에는 제네릭 타입에 대한 정보가 없다.
### 열거형(enumeration)

### 애너테이션(annotation)
